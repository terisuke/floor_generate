# å®Œå…¨ç‰ˆMVPè¦ä»¶å®šç¾©æ›¸ â€” 910mmã‚°ãƒªãƒƒãƒ‰ä½å®…ãƒ—ãƒ©ãƒ³è‡ªå‹•ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 

---

## ğŸ“‹ ç›®æ¬¡
1. [ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦](#1-ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦)
2. [ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ](#2-ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ)  
3. [é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—](#3-é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—)
4. [ãƒ‡ãƒ¼ã‚¿å‰å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³](#4-ãƒ‡ãƒ¼ã‚¿å‰å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³)
5. [AIå­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ ](#5-aiå­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ )
6. [åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ãƒ»æœ€é©åŒ–](#6-åˆ¶ç´„ãƒã‚§ãƒƒã‚¯æœ€é©åŒ–)
7. [FreeCADé€£æºã‚·ã‚¹ãƒ†ãƒ ](#7-freecadé€£æºã‚·ã‚¹ãƒ†ãƒ )
8. [UIãƒ»çµ±åˆã‚·ã‚¹ãƒ†ãƒ ](#8-uiçµ±åˆã‚·ã‚¹ãƒ†ãƒ )
9. [é–‹ç™ºã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«](#9-é–‹ç™ºã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«)
10. [ãƒ†ã‚¹ãƒˆãƒ»è©•ä¾¡](#10-ãƒ†ã‚¹ãƒˆè©•ä¾¡)

---

## 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

### ğŸ¯ ç›®çš„
MacBook Pro (M4 Max 128GB RAM) ä¸Šã§ã€å»ºç¯‰å›³é¢PDFã‚’å­¦ç¿’ã—ã€910mm/455mmæ··åˆã‚°ãƒªãƒƒãƒ‰å¯¸æ³•ã§ä½å®…å¹³é¢å›³ã‚’è‡ªå‹•ç”Ÿæˆã€‚CP-SATåˆ¶ç´„ãƒã‚§ãƒƒã‚¯å¾Œã€FreeCADã§ç·¨é›†å¯èƒ½ãª2D/3Dãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã™ã‚‹çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã€‚

### âœ… èª¿æ•´æ¸ˆã¿æˆåŠŸåŸºæº–
1. **å‡¦ç†æ™‚é–“**: å…¥åŠ›ã€œå‡ºåŠ›ã¾ã§ **5ç§’ä»¥å†…/ä»¶**
2. **å“è³ª**: CPâ€‘SATæ¤œè¨¼å¾Œã® **60%ä»¥ä¸ŠãŒæ‰‹å‹•ä¿®æ­£ä¸è¦**  
3. **CADé€£æº**: FreeCADã§å£åšãƒ»éšæ®µä½ç½®ä¿æŒã—ãŸ3DæŠ¼ã—å‡ºã—å®Ÿç¾
4. **å¯¸æ³•ç²¾åº¦**: 910mmä¸»ã‚°ãƒªãƒƒãƒ‰ + 455mmå‰¯ã‚°ãƒªãƒƒãƒ‰ã§**èª¤å·®5%ä»¥å†…**

### ğŸ—ï¸ å¯¾è±¡å»ºç‰©
- 2éšå»ºã¦åœ¨æ¥æœ¨é€ ä½å®…ï¼ˆæ—¥æœ¬æ¨™æº–ä»•æ§˜ï¼‰
- æ•·åœ°: çŸ©å½¢ï¼ˆ8Ã—6ã€œ15Ã—12ã‚°ãƒªãƒƒãƒ‰ï¼‰
- éƒ¨å±‹æ•°: 3LDKã€œ5LDK
- å»¶åºŠé¢ç©: 80ã€œ140ã¡

---

## 2. ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ

```mermaid
graph TD
    A[PDFå›³é¢é›†<br>1000æš] --> B[å¯¸æ³•æŠ½å‡ºãƒ»OCR]
    B --> C[æ··åˆã‚°ãƒªãƒƒãƒ‰æ­£è¦åŒ–<br>910mm + 455mm]
    C --> D[SVGâ†’PNGå¤‰æ›<br>256Ã—256px]
    D --> E[å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ]
    E --> F[SD 2.1 + LoRAå­¦ç¿’]
    
    G[Streamlit UI<br>ã‚°ãƒªãƒƒãƒ‰å…¥åŠ›] --> H[æ•·åœ°ãƒã‚¹ã‚¯ç”Ÿæˆ]
    H --> I[SDæ¨è«–<br>å¹³é¢å›³ç”Ÿæˆ]
    I --> J[CP-SATåˆ¶ç´„ãƒã‚§ãƒƒã‚¯]
    J --> K[æœ€å°ä¿®å¾©æœ€é©åŒ–]
    K --> L[ãƒ™ã‚¯ã‚¿å¤‰æ›<br>SVG/DXF]
    L --> M[FreeCAD Python API]
    M --> N[3Dãƒ¢ãƒ‡ãƒ«<br>FCStdå‡ºåŠ›]
```

---

## 3. é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

### 3.1 ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶
```bash
# ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢
- MacBook Pro M4 Max (æ¨å¥¨) / Ubuntu 22.04 (x86_64)
- RAM: 64GBä»¥ä¸Š (128GBæ¨å¥¨)
- Storage: 100GBä»¥ä¸Šã®ç©ºãå®¹é‡

# ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢
- macOS 14.0ä»¥ä¸Š / Ubuntu 22.04ä»¥ä¸Š
- Python 3.11
- FreeCAD 0.22
- Git, Homebrew (macOS) / APT (Ubuntu)
```

### 3.2 ç’°å¢ƒæ§‹ç¯‰æ‰‹é †

#### macOSç’°å¢ƒ
```bash
cd ~/repos/floor_generate

# 1. åŸºæœ¬ãƒ„ãƒ¼ãƒ«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
brew install python@3.11 freecad git cmake pkg-config poppler tesseract tesseract-lang

# 2. Pythonä»®æƒ³ç’°å¢ƒ
python3.11 -m venv floorplan_env
source floorplan_env/bin/activate

# 3. PyTorch (MPSå¯¾å¿œ)
pip install --upgrade pip setuptools wheel
pip install torch==2.3.0 torchvision torchaudio

# 4. ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pip install -r requirements.txt
```

#### Ubuntu 22.04ç’°å¢ƒ
```bash
cd ~/repos/floor_generate

# 1. ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
sudo apt update
sudo apt install -y software-properties-common
sudo add-apt-repository ppa:deadsnakes/ppa -y
sudo apt update
sudo apt install -y python3.11 python3.11-venv python3.11-dev
sudo apt install -y poppler-utils tesseract-ocr tesseract-ocr-jpn
sudo apt install -y cmake pkg-config git

# 2. Pythonä»®æƒ³ç’°å¢ƒ
python3.11 -m venv floorplan_env
source floorplan_env/bin/activate

# 3. PyTorch (CPUç‰ˆ)
pip install --upgrade pip setuptools wheel
pip install torch==2.3.0 torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu

# 4. AI/ML ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆäº’æ›æ€§ç¢ºèªæ¸ˆã¿ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼‰
pip install diffusers==0.19.3 transformers==4.31.0 huggingface_hub==0.16.4
pip install peft==0.4.0 tokenizers==0.13.3 accelerate==0.25.0
# æ³¨æ„: ä¸Šè¨˜ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯äº’æ›æ€§ãƒ†ã‚¹ãƒˆæ¸ˆã¿ã§ã™ã€‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³å¤‰æ›´æ™‚ã¯æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

# 5. CAD/ç”»åƒå‡¦ç†
pip install opencv-python==4.8.1.78 Pillow==10.1.0
pip install svgwrite==1.4.3 svglib==1.5.1 shapely==2.0.2
pip install reportlab==4.0.7  # PDFå‡¦ç†

# 6. OCR/å‰å‡¦ç†
pip install pytesseract==0.3.10 pdf2image==1.16.3
pip install easyocr==1.7.0  # æ—¥æœ¬èªå¯¾å¿œOCR

# 7. åˆ¶ç´„æœ€é©åŒ–
pip install ortools==9.8.3296

# 8. UIãƒ»ãã®ä»–
pip install streamlit==1.28.0 pandas==2.1.3 numpy==1.24.4

# 9. FreeCAD Pythoné€£æº
pip install freecad  # FreeCAD Python binding
```

### 3.3 ä¾å­˜é–¢ä¿‚ã®äº’æ›æ€§

ä»¥ä¸‹ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–“ã«ã¯äº’æ›æ€§ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ï¼š
- `huggingface_hub`
- `diffusers`
- `transformers`

äº’æ›æ€§ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³çµ„ã¿åˆã‚ã›ï¼š
```
diffusers==0.19.3
transformers==4.31.0
huggingface_hub==0.16.4
peft==0.4.0
tokenizers==0.13.3
```

äº’æ›æ€§å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã®ãƒ‘ãƒƒãƒã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼š
```python
# ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å…ˆé ­ã«è¿½åŠ 
import patch_diffusers
patch_diffusers.apply_patches()
```

è©³ç´°ã¯ `dependency_compatibility.md` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

### 3.3 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 
```
floorplan_mvp/
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ raw_pdfs/          # å…ƒPDFå›³é¢ï¼ˆ1000æšï¼‰
â”‚   â”œâ”€â”€ extracted/         # å¯¸æ³•æŠ½å‡ºçµæœ
â”‚   â”œâ”€â”€ normalized/        # ã‚°ãƒªãƒƒãƒ‰æ­£è¦åŒ–æ¸ˆã¿
â”‚   â”œâ”€â”€ training/          # å­¦ç¿’ç”¨ãƒ‡ãƒ¼ã‚¿ãƒšã‚¢
â”‚   â””â”€â”€ validation/        # æ¤œè¨¼ç”¨ãƒ‡ãƒ¼ã‚¿
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ preprocessing/     # å‰å‡¦ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
â”‚   â”œâ”€â”€ training/          # AIå­¦ç¿’
â”‚   â”œâ”€â”€ inference/         # æ¨è«–ãƒ»ç”Ÿæˆ
â”‚   â”œâ”€â”€ constraints/       # CP-SATåˆ¶ç´„
â”‚   â”œâ”€â”€ freecad_bridge/    # FreeCADé€£æº
â”‚   â””â”€â”€ ui/               # Streamlit UI
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ lora_weights/     # å­¦ç¿’æ¸ˆã¿LoRAãƒ¢ãƒ‡ãƒ«
â”‚   â””â”€â”€ checkpoints/      # å­¦ç¿’ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ
â”œâ”€â”€ outputs/
â”‚   â”œâ”€â”€ generated/        # ç”Ÿæˆã•ã‚ŒãŸå¹³é¢å›³
â”‚   â”œâ”€â”€ svg/              # ãƒ™ã‚¯ã‚¿å½¢å¼
â”‚   â”œâ”€â”€ dxf/              # CADäº¤æ›å½¢å¼
â”‚   â””â”€â”€ freecad/          # 3Dãƒ¢ãƒ‡ãƒ«
â”œâ”€â”€ tests/                # ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
â”œâ”€â”€ scripts/              # å®Ÿè¡Œã‚¹ã‚¯ãƒªãƒ—ãƒˆ
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
```

---

## 4. ãƒ‡ãƒ¼ã‚¿å‰å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

### 4.1 PDFå¯¸æ³•æŠ½å‡ºã‚·ã‚¹ãƒ†ãƒ 

```python
# src/preprocessing/dimension_extractor.py
import cv2, re, numpy as np
import pytesseract, easyocr
from pdf2image import convert_from_path

class DimensionExtractor:
    def __init__(self):
        self.reader = easyocr.Reader(['ja', 'en'])
        
    def extract_from_pdf(self, pdf_path):
        """PDFã‹ã‚‰å¯¸æ³•æƒ…å ±ã‚’æŠ½å‡º"""
        
        # 1. PDFâ†’é«˜è§£åƒåº¦ç”»åƒå¤‰æ›
        images = convert_from_path(pdf_path, dpi=300)
        
        all_dimensions = []
        for page_num, img in enumerate(images):
            # 2. å‰å‡¦ç†ï¼ˆãƒã‚¤ã‚ºé™¤å»ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆå¼·åŒ–ï¼‰
            processed = self.preprocess_image(np.array(img))
            
            # 3. å¯¸æ³•ãƒ†ã‚­ã‚¹ãƒˆæ¤œå‡º
            dimensions = self.detect_dimensions(processed)
            all_dimensions.extend(dimensions)
            
        return self.validate_dimensions(all_dimensions)
    
    def detect_dimensions(self, image):
        """ç”»åƒã‹ã‚‰å¯¸æ³•æ•°å€¤ã‚’æ¤œå‡º"""
        
        # OCRã§æ–‡å­—æ¤œå‡º
        results = self.reader.readtext(image)
        dimensions = []
        
        for (bbox, text, confidence) in results:
            if confidence > 0.7:
                # å¯¸æ³•ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
                patterns = [
                    r'(\d{1,2}),(\d{3})',      # 9,100å½¢å¼
                    r'(\d{4,5})',              # 9100å½¢å¼
                    r'(\d+)Ã—(\d+)',            # æ¨ªÃ—ç¸¦å½¢å¼
                ]
                
                for pattern in patterns:
                    matches = re.findall(pattern, text)
                    for match in matches:
                        if isinstance(match, tuple):
                            if len(match) == 2 and ',' in text:
                                # 9,100 â†’ 9100
                                dim = int(match[0]) * 1000 + int(match[1])
                            else:
                                # æ¨ªÃ—ç¸¦
                                dim = [int(match[0]), int(match[1])]
                        else:
                            dim = int(match)
                        
                        if self.is_valid_dimension(dim):
                            dimensions.append({
                                'value': dim,
                                'bbox': bbox,
                                'confidence': confidence,
                                'text': text
                            })
        
        return dimensions
```

### 4.2 æ··åˆã‚°ãƒªãƒƒãƒ‰æ­£è¦åŒ–

```python
# src/preprocessing/grid_normalizer.py
class GridNormalizer:
    def __init__(self, primary_grid=910, secondary_grid=455):
        self.primary = primary_grid    # 910mm (æœ¬é–“)
        self.secondary = secondary_grid # 455mm (åŠé–“)
        
    def normalize_dimensions(self, dimensions):
        """å¯¸æ³•ã‚’æ··åˆã‚°ãƒªãƒƒãƒ‰ã«æ­£è¦åŒ–"""
        
        normalized = []
        for dim_info in dimensions:
            dim = dim_info['value']
            
            if isinstance(dim, list):
                # æ¨ªÃ—ç¸¦ã®å ´åˆ
                norm_dims = [self.normalize_single(d) for d in dim]
                normalized.append({
                    'original': dim,
                    'normalized': norm_dims,
                    'grid_type': 'site_size',
                    'confidence': dim_info['confidence']
                })
            else:
                # å˜ä¸€å¯¸æ³•
                norm_dim = self.normalize_single(dim)
                normalized.append({
                    'original': dim,
                    'normalized': norm_dim,
                    'grid_type': norm_dim['grid_type'],
                    'confidence': dim_info['confidence']
                })
        
        return normalized
    
    def normalize_single(self, dimension):
        """å˜ä¸€å¯¸æ³•ã®æ­£è¦åŒ–"""
        
        # ä¸»ã‚°ãƒªãƒƒãƒ‰ï¼ˆ910mmï¼‰ã§ã®è¿‘ä¼¼
        primary_grids = round(dimension / self.primary)
        primary_error = abs(dimension - primary_grids * self.primary)
        
        # å‰¯ã‚°ãƒªãƒƒãƒ‰ï¼ˆ455mmï¼‰ã§ã®è¿‘ä¼¼  
        secondary_grids = round(dimension / self.secondary)
        secondary_error = abs(dimension - secondary_grids * self.secondary)
        
        # ã‚ˆã‚Šèª¤å·®ã®å°ã•ã„æ–¹ã‚’æ¡ç”¨
        if primary_error <= secondary_error:
            return {
                'normalized_mm': primary_grids * self.primary,
                'grid_count': primary_grids,
                'grid_type': 'primary',  # 910mm
                'error_mm': primary_error,
                'error_percent': primary_error / dimension * 100
            }
        else:
            return {
                'normalized_mm': secondary_grids * self.secondary,
                'grid_count': secondary_grids,
                'grid_type': 'secondary',  # 455mm
                'error_mm': secondary_error,
                'error_percent': secondary_error / dimension * 100
            }
```

### 4.3 å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ

```python
# src/preprocessing/training_data_generator.py
class TrainingDataGenerator:
    def __init__(self, target_size=(256, 256)):
        self.target_size = target_size
        self.extractor = DimensionExtractor()
        self.normalizer = GridNormalizer()
        
    def process_pdf_collection(self, pdf_dir, output_dir):
        """1000æšã®PDFé›†ã‚’å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›"""
        
        pdf_files = glob(f"{pdf_dir}/*.pdf")
        print(f"Processing {len(pdf_files)} PDF files...")
        
        successful = 0
        for i, pdf_path in enumerate(pdf_files):
            try:
                print(f"[{i+1}/{len(pdf_files)}] {pdf_path}")
                
                # 1. å¯¸æ³•æŠ½å‡º
                dimensions = self.extractor.extract_from_pdf(pdf_path)
                
                # 2. ã‚°ãƒªãƒƒãƒ‰æ­£è¦åŒ–
                normalized = self.normalizer.normalize_dimensions(dimensions)
                
                # 3. PDFâ†’SVGå¤‰æ›
                svg_path = self.pdf_to_svg(pdf_path)
                
                # 4. SVGâ†’ã‚°ãƒªãƒƒãƒ‰ç”»åƒå¤‰æ›
                grid_image = self.svg_to_grid_image(svg_path, normalized)
                
                # 5. å»ºç¯‰è¦ç´ åˆ†é›¢
                channels = self.separate_elements(grid_image)
                
                # 6. æ•·åœ°ãƒã‚¹ã‚¯ç”Ÿæˆ
                site_mask = self.create_site_mask(normalized)
                
                # 7. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
                metadata = self.create_metadata(normalized, channels)
                
                # 8. ä¿å­˜
                self.save_training_pair(
                    site_mask, channels, metadata, 
                    f"{output_dir}/pair_{i:04d}"
                )
                
                successful += 1
                
            except Exception as e:
                print(f"Error processing {pdf_path}: {e}")
                continue
        
        print(f"Successfully processed: {successful}/{len(pdf_files)} files")
        return successful
    
    def separate_elements(self, grid_image):
        """å»ºç¯‰è¦ç´ ã‚’ãƒãƒ£ãƒ³ãƒãƒ«åˆ†é›¢"""
        
        # è‰²ãƒ™ãƒ¼ã‚¹åˆ†é›¢ï¼ˆä»®å®šï¼šé»’=å£ã€ãã®ä»–=è¦ç´ ï¼‰
        gray = cv2.cvtColor(grid_image, cv2.COLOR_BGR2GRAY)
        
        # å£ï¼ˆå¤ªã„ç·šï¼‰æ¤œå‡º
        walls = self.detect_walls(gray)
        
        # é–‹å£éƒ¨ï¼ˆç´°ã„ç·šï¼‰æ¤œå‡º  
        openings = self.detect_openings(gray)
        
        # éšæ®µï¼ˆç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰æ¤œå‡º
        stairs = self.detect_stairs(gray)
        
        # éƒ¨å±‹é ˜åŸŸï¼ˆå£ã§å›²ã¾ã‚ŒãŸé ˜åŸŸï¼‰
        rooms = self.detect_rooms(walls)
        
        # 4ãƒãƒ£ãƒ³ãƒãƒ«ç”»åƒã¨ã—ã¦çµåˆ
        rgba = np.zeros((self.target_size[0], self.target_size[1], 4), dtype=np.uint8)
        rgba[:,:,0] = walls      # Red: å£
        rgba[:,:,1] = openings   # Green: é–‹å£éƒ¨
        rgba[:,:,2] = stairs     # Blue: éšæ®µ
        rgba[:,:,3] = rooms      # Alpha: éƒ¨å±‹
        
        return rgba
```

---

## 5. AIå­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ 

### 5.1 LoRAå­¦ç¿’è¨­å®š âœ…

```python
# src/training/lora_trainer.py
from diffusers import StableDiffusionPipeline, DDPMScheduler
from peft import LoraConfig, get_peft_model
import torch

class LoRATrainer:
    def __init__(self):
        self.device = "mps" if torch.backends.mps.is_available() else "cpu"
        
        # Base model - using v1-4 which is open access and smaller
        self.model_id = "CompVis/stable-diffusion-v1-4"
        
        # Force CPU mode for testing if no GPU available
        if self.device == "cpu":
            print("Running on CPU - using float32 for compatibility")
            self.dtype = torch.float32
        else:
            self.dtype = torch.float16
            
        # Load model with appropriate dtype
        self.pipeline = StableDiffusionPipeline.from_pretrained(
            self.model_id,
            torch_dtype=self.dtype,
            use_auth_token=False,
            safety_checker=None,
            requires_safety_checker=False
        ).to(self.device)
        
        # LoRAè¨­å®š - è»½é‡åŒ–ã®ãŸã‚ã«rankã‚’ä¸‹ã’ã‚‹
        self.lora_config = LoraConfig(
            r=32,                    # Rank (è»½é‡åŒ–)
            lora_alpha=32,
            target_modules=[
                "to_k", "to_q", "to_v", "to_out.0",
                "proj_in", "proj_out",
            ],
            lora_dropout=0.1,
        )
    
    def train(self, train_dataloader, num_epochs=20):
        """LoRAå­¦ç¿’å®Ÿè¡Œ"""
        
        # UNetã«LoRAé©ç”¨
        unet = get_peft_model(self.pipeline.unet, self.lora_config)
        
        optimizer = torch.optim.AdamW(
            unet.parameters(), 
            lr=1e-4,
            weight_decay=1e-2
        )
        
        # å­¦ç¿’ãƒ«ãƒ¼ãƒ—
        for epoch in range(num_epochs):
            total_loss = 0
            for batch_idx, batch in enumerate(train_dataloader):
                
                # ãƒãƒƒãƒãƒ‡ãƒ¼ã‚¿
                site_masks = batch['condition'].to(self.device)
                target_plans = batch['target'].to(self.device)
                prompts = batch['prompt']
                
                # ãƒã‚¤ã‚ºè¿½åŠ 
                noise = torch.randn_like(target_plans)
                timesteps = torch.randint(0, 1000, (target_plans.shape[0],))
                
                noisy_plans = self.pipeline.scheduler.add_noise(
                    target_plans, noise, timesteps
                )
                
                # äºˆæ¸¬
                with torch.cuda.amp.autocast():
                    # ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
                    text_embeddings = self.pipeline.text_encoder(
                        self.pipeline.tokenizer(
                            prompts, 
                            padding=True, 
                            return_tensors="pt"
                        ).input_ids.to(self.device)
                    )[0]
                    
                    # UNetäºˆæ¸¬
                    noise_pred = unet(
                        noisy_plans,
                        timesteps.to(self.device),
                        encoder_hidden_states=text_embeddings,
                        return_dict=False
                    )[0]
                    
                    # Lossè¨ˆç®—
                    loss = F.mse_loss(noise_pred, noise, reduction="mean")
                
                # ãƒãƒƒã‚¯ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
                optimizer.zero_grad()
                loss.backward()
                optimizer.step()
                
                total_loss += loss.item()
                
                if batch_idx % 50 == 0:
                    print(f"Epoch {epoch}, Batch {batch_idx}, Loss: {loss.item():.4f}")
            
            print(f"Epoch {epoch} completed. Average Loss: {total_loss/len(train_dataloader):.4f}")
            
            # ãƒ¢ãƒ‡ãƒ«ä¿å­˜
            if epoch % 5 == 0:
                unet.save_pretrained(f"models/lora_weights/epoch_{epoch}")
```

### 5.2 ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ€ãƒ¼

```python
# src/training/dataset.py
class FloorPlanDataset(Dataset):
    def __init__(self, data_dir, transform=None):
        self.data_dir = data_dir
        self.transform = transform
        self.pairs = self.load_data_pairs()
        
    def load_data_pairs(self):
        """å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãƒšã‚¢ã‚’èª­ã¿è¾¼ã¿"""
        pairs = []
        for pair_dir in glob(f"{self.data_dir}/pair_*"):
            metadata_path = f"{pair_dir}/metadata.json"
            if os.path.exists(metadata_path):
                with open(metadata_path, 'r') as f:
                    metadata = json.load(f)
                pairs.append({
                    'dir': pair_dir,
                    'metadata': metadata
                })
        return pairs
    
    def __getitem__(self, idx):
        pair = self.pairs[idx]
        pair_dir = pair['dir']
        metadata = pair['metadata']
        
        # ç”»åƒèª­ã¿è¾¼ã¿
        site_mask = cv2.imread(f"{pair_dir}/site_mask.png", cv2.IMREAD_GRAYSCALE)
        floor_plan = cv2.imread(f"{pair_dir}/floor_plan.png", cv2.IMREAD_UNCHANGED)
        
        # æ­£è¦åŒ–
        site_mask = site_mask.astype(np.float32) / 255.0
        floor_plan = floor_plan.astype(np.float32) / 255.0
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ
        prompt = self.generate_prompt(metadata)
        
        # Tensorå¤‰æ›
        site_mask = torch.from_numpy(site_mask).unsqueeze(0)  # [1, H, W]
        floor_plan = torch.from_numpy(floor_plan).permute(2, 0, 1)  # [4, H, W]
        
        return {
            'condition': site_mask,
            'target': floor_plan,
            'prompt': prompt,
            'metadata': metadata
        }
    
    def generate_prompt(self, metadata):
        """ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ"""
        grid_size = metadata['site_grid_size']
        area = metadata['total_area_sqm']
        rooms = metadata['room_count']
        
        prompt = f"site_size_{grid_size[0]}x{grid_size[1]}, "
        prompt += f"total_area_{area:.0f}sqm, "
        prompt += f"rooms_{rooms}, "
        prompt += "japanese_house, 910mm_grid, architectural_plan"
        
        return prompt
```

---

## 6. åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ãƒ»æœ€é©åŒ–

### 6.1 CP-SATåˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ 

```python
# src/constraints/architectural_constraints.py
from ortools.sat.python import cp_model

class ArchitecturalConstraints:
    def __init__(self):
        self.model = cp_model.CpModel()
        self.solver = cp_model.CpSolver()
        
    def validate_and_fix(self, floor_plan_image):
        """å¹³é¢å›³ã®åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ã¨æœ€å°ä¿®å¾©"""
        
        # 1. ã‚°ãƒªãƒƒãƒ‰åŒ–
        grid = self.image_to_grid(floor_plan_image)
        height, width = grid.shape
        
        # 2. å¤‰æ•°å®šç¾©
        variables = self.define_variables(height, width)
        
        # 3. åˆ¶ç´„å®šç¾©
        self.add_wall_constraints(variables, grid)
        self.add_room_constraints(variables, grid)
        self.add_connectivity_constraints(variables, grid)
        self.add_stair_constraints(variables, grid)
        
        # 4. ç›®çš„é–¢æ•°ï¼ˆæœ€å°å¤‰æ›´ï¼‰
        repair_vars = self.add_repair_variables(variables, grid)
        self.model.Minimize(sum(repair_vars))
        
        # 5. æ±‚è§£
        status = self.solver.Solve(self.model)
        
        if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
            return self.extract_solution(variables, height, width)
        else:
            return None
    
    def add_wall_constraints(self, variables, grid):
        """å£ã®åˆ¶ç´„"""
        height, width = grid.shape
        
        for i in range(height):
            for j in range(width):
                if grid[i, j] == 1:  # å£ã‚»ãƒ«
                    # å£ã®é€£ç¶šæ€§åˆ¶ç´„
                    neighbors = self.get_neighbors(i, j, height, width)
                    wall_neighbors = [variables['wall'][ni][nj] for ni, nj in neighbors]
                    
                    # å£ã¯0å€‹ã€2å€‹ã€ã¾ãŸã¯4å€‹ã®éš£æ¥å£ã‚’æŒã¤
                    neighbor_sum = sum(wall_neighbors)
                    self.model.AddAllowedAssignments(
                        [neighbor_sum], 
                        [[0], [2], [4]]
                    )
    
    def add_room_constraints(self, variables, grid):
        """éƒ¨å±‹ã®åˆ¶ç´„"""
        # æœ€å°é¢ç©åˆ¶ç´„
        min_area_sqm = 6  # 6ã¡
        min_area_grids = int(min_area_sqm / (0.91 * 0.91))  # ã‚°ãƒªãƒƒãƒ‰æ•°æ›ç®—
        
        room_cells = variables['rooms']
        for room_id in range(1, 10):  # æœ€å¤§10éƒ¨å±‹
            room_area = []
            for i in range(len(room_cells)):
                for j in range(len(room_cells[0])):
                    is_room = self.model.NewBoolVar(f'is_room_{room_id}_{i}_{j}')
                    self.model.Add(is_room == (room_cells[i][j] == room_id))
                    room_area.append(is_room)
            
            # éƒ¨å±‹ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€æœ€å°é¢ç©ã‚’æº€ãŸã™
            room_exists = self.model.NewBoolVar(f'room_exists_{room_id}')
            self.model.Add(sum(room_area) >= min_area_grids).OnlyEnforceIf(room_exists)
            self.model.Add(sum(room_area) == 0).OnlyEnforceIf(room_exists.Not())
    
    def add_stair_constraints(self, variables, grid):
        """éšæ®µã®åˆ¶ç´„"""
        stair_1f = variables['stairs_1f']
        stair_2f = variables['stairs_2f']
        
        height, width = len(stair_1f), len(stair_1f[0])
        
        # 1Féšæ®µã¨2Féšæ®µã¯åŒã˜ä½ç½®
        for i in range(height):
            for j in range(width):
                self.model.Add(stair_1f[i][j] == stair_2f[i][j])
        
        # éšæ®µã¯é€£ç¶šã—ãŸé ˜åŸŸ
        stair_cells = []
        for i in range(height):
            for j in range(width):
                stair_cells.append(stair_1f[i][j])
        
        # éšæ®µã®æœ€å°ãƒ»æœ€å¤§é¢ç©
        total_stairs = sum(stair_cells)
        self.model.Add(total_stairs >= 4)   # æœ€å°4ã‚°ãƒªãƒƒãƒ‰
        self.model.Add(total_stairs <= 12)  # æœ€å¤§12ã‚°ãƒªãƒƒãƒ‰
```

---

## 7. FreeCADé€£æºã‚·ã‚¹ãƒ†ãƒ 

### 7.1 FreeCADæ©‹æ¸¡ã—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

```python
# src/freecad_bridge/fcstd_generator.py
import FreeCAD as App
import Draft, Arch, Part
import numpy as np
from shapely.geometry import Polygon, Point

class FreeCADGenerator:
    def __init__(self):
        self.doc = None
        self.wall_height = 2400  # mm
        self.wall_thickness = 105  # mm (åœ¨æ¥å·¥æ³•æ¨™æº–)
        
    def create_3d_model(self, validated_plan, metadata, output_path):
        """æ¤œè¨¼æ¸ˆã¿å¹³é¢å›³ã‹ã‚‰3Dãƒ¢ãƒ‡ãƒ«ç”Ÿæˆ"""
        
        # 1. æ–°è¦æ–‡æ›¸ä½œæˆ
        self.doc = App.newDocument("FloorPlan")
        
        # 2. ã‚°ãƒªãƒƒãƒ‰ã‹ã‚‰å®Ÿå¯¸æ³•å¤‰æ›
        grid_to_mm = self.create_scale_converter(metadata)
        
        # 3. å£ç”Ÿæˆ
        walls = self.create_walls(validated_plan, grid_to_mm)
        
        # 4. é–‹å£éƒ¨ç”Ÿæˆ
        openings = self.create_openings(validated_plan, grid_to_mm, walls)
        
        # 5. éšæ®µç”Ÿæˆ
        stairs = self.create_stairs(validated_plan, grid_to_mm)
        
        # 6. ãƒ•ãƒ­ã‚¢ç”Ÿæˆ
        floors = self.create_floors(validated_plan, grid_to_mm)
        
        # 7. å»ºç‰©çµåˆ
        building = self.create_building([walls, floors, stairs])
        
        # 8. ä¿å­˜
        self.doc.saveAs(output_path)
        
        return {
            'fcstd_path': output_path,
            'components': {
                'walls': len(walls),
                'openings': len(openings),
                'stairs': len(stairs),
                'floors': len(floors)
            }
        }
    
    def create_walls(self, plan, grid_to_mm):
        """å£ã‚’ç”Ÿæˆ"""
        walls = []
        
        # å£ã®è¼ªéƒ­æŠ½å‡º
        wall_contours = self.extract_wall_contours(plan)
        
        for contour in wall_contours:
            # ã‚°ãƒªãƒƒãƒ‰åº§æ¨™â†’å®Ÿåº§æ¨™å¤‰æ›
            real_points = []
            for point in contour:
                real_x = point[0] * grid_to_mm['primary']  # 910mm
                real_y = point[1] * grid_to_mm['primary']
                real_points.append(App.Vector(real_x, real_y, 0))
            
            # Draftç·šä½œæˆ
            wire = Draft.makeWire(real_points, closed=True)
            
            # å£ã«å¤‰æ›
            wall = Arch.makeWall(
                wire, 
                length=None,
                width=self.wall_thickness,
                height=self.wall_height
            )
            
            # ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£è¨­å®š
            wall.Label = f"Wall_{len(walls)+1}"
            wall.Material = "Concrete"  # æè³ªè¨­å®š
            
            walls.append(wall)
        
        return walls
    
    def create_openings(self, plan, grid_to_mm, walls):
        """é–‹å£éƒ¨ï¼ˆãƒ‰ã‚¢ãƒ»çª“ï¼‰ã‚’ç”Ÿæˆ"""
        openings = []
        
        # é–‹å£éƒ¨ä½ç½®æ¤œå‡º
        opening_positions = self.detect_openings(plan)
        
        for pos in opening_positions:
            # æœ€å¯„ã‚Šã®å£ã‚’æ¤œç´¢
            nearest_wall = self.find_nearest_wall(pos, walls)
            
            if nearest_wall:
                # é–‹å£éƒ¨ã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆãƒ‰ã‚¢/çª“ï¼‰
                opening_type = self.classify_opening(plan, pos)
                
                if opening_type == 'door':
                    opening = self.create_door(pos, nearest_wall, grid_to_mm)
                else:
                    opening = self.create_window(pos, nearest_wall, grid_to_mm)
                
                openings.append(opening)
        
        return openings
    
    def create_door(self, position, wall, grid_to_mm):
        """ãƒ‰ã‚¢ç”Ÿæˆ"""
        # ãƒ‰ã‚¢å¯¸æ³•ï¼ˆæ¨™æº–ï¼‰
        door_width = 780  # mm
        door_height = 2000  # mm
        
        # ä½ç½®è¨ˆç®—
        real_x = position[0] * grid_to_mm['primary']
        real_y = position[1] * grid_to_mm['primary']
        
        # ãƒ‰ã‚¢é–‹å£éƒ¨ä½œæˆ
        door_rect = Draft.makeRectangle(
            door_width, 
            self.wall_thickness,
            App.Vector(real_x, real_y, 0)
        )
        
        # å£ã‹ã‚‰é–‹å£éƒ¨ã‚’ãƒ–ãƒ¼ãƒ«æ¼”ç®—ã§é™¤å»
        opening = Arch.makeWindow(
            door_rect,
            wall,
            name="Door"
        )
        
        return opening
    
    def create_stairs(self, plan, grid_to_mm):
        """éšæ®µç”Ÿæˆ"""
        stairs = []
        
        # éšæ®µä½ç½®æ¤œå‡º
        stair_positions = self.detect_stairs(plan)
        
        for pos in stair_positions:
            # éšæ®µå¯¸æ³•è¨ˆç®—
            stair_width = 910  # mmï¼ˆ1ã‚°ãƒªãƒƒãƒ‰ï¼‰
            stair_length = pos['length'] * grid_to_mm['primary']
            step_height = 200  # mm
            step_count = int(self.wall_height / step_height)
            
            # å®Ÿåº§æ¨™å¤‰æ›
            real_x = pos['x'] * grid_to_mm['primary']
            real_y = pos['y'] * grid_to_mm['primary']
            
            # éšæ®µä½œæˆ
            stair = Arch.makeStairs(
                length=stair_length,
                width=stair_width,
                height=self.wall_height,
                steps=step_count
            )
            
            # ä½ç½®è¨­å®š
            stair.Placement.Base = App.Vector(real_x, real_y, 0)
            stair.Label = f"Stairs_{len(stairs)+1}"
            
            stairs.append(stair)
        
        return stairs
    
    def create_building(self, components):
        """å»ºç‰©å…¨ä½“ã‚’çµ±åˆ"""
        
        # Buildingä½œæˆ
        building = Arch.makeBuilding()
        building.Label = "Generated_House"
        
        # ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¿½åŠ 
        all_objects = []
        for component_list in components:
            all_objects.extend(component_list)
        
        building.Group = all_objects
        
        # ãƒ“ãƒ¥ãƒ¼æ›´æ–°
        self.doc.recompute()
        
        return building
```

### 7.2 ç·¨é›†å¯èƒ½æ€§ã®ç¢ºä¿

```python
# src/freecad_bridge/editing_features.py
class EditingFeatures:
    def __init__(self, fcstd_doc):
        self.doc = fcstd_doc
        
    def setup_parametric_features(self):
        """ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ç·¨é›†æ©Ÿèƒ½ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
        
        # 1. å¯¸æ³•ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä½œæˆ
        self.doc.addObject("App::PropertyLength", "WallHeight")
        self.doc.WallHeight = 2400  # mm
        
        self.doc.addObject("App::PropertyLength", "WallThickness")  
        self.doc.WallThickness = 105  # mm
        
        # 2. å£ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒªãƒ³ã‚¯
        for obj in self.doc.Objects:
            if hasattr(obj, 'Height') and 'Wall' in obj.Label:
                # å£ã®é«˜ã•ã‚’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ãƒªãƒ³ã‚¯
                obj.setExpression('Height', 'WallHeight')
                obj.setExpression('Width', 'WallThickness')
        
        # 3. ã‚¹ã‚±ãƒƒãƒç·¨é›†å¯èƒ½æ€§
        self.make_sketches_editable()
        
        self.doc.recompute()
    
    def make_sketches_editable(self):
        """ã‚¹ã‚±ãƒƒãƒã‚’ç·¨é›†å¯èƒ½ã«ã™ã‚‹"""
        
        # å¹³é¢å›³ã®åŸºæº–ã‚¹ã‚±ãƒƒãƒã‚’ä½œæˆ
        base_sketch = self.doc.addObject("Sketcher::SketchObject", "FloorPlanSketch")
        
        # å£ã®ä¸­å¿ƒç·šã‚’ã‚¹ã‚±ãƒƒãƒã«è¿½åŠ 
        wall_centerlines = self.extract_wall_centerlines()
        for line in wall_centerlines:
            base_sketch.addGeometry(Part.LineSegment(line[0], line[1]))
        
        # å¯¸æ³•åˆ¶ç´„è¿½åŠ 
        self.add_dimensional_constraints(base_sketch)
        
    def export_for_editing(self, export_formats=['step', 'iges', 'dxf']):
        """ä»–ã®CADã‚½ãƒ•ãƒˆç”¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
        
        exports = {}
        
        for format in export_formats:
            if format == 'step':
                # STEPå½¢å¼ï¼ˆ3Dï¼‰
                output_path = self.doc.FileName.replace('.FCStd', '.step')
                import Import
                Import.export(self.doc.Objects, output_path)
                exports['step'] = output_path
                
            elif format == 'dxf':
                # DXFå½¢å¼ï¼ˆ2Då›³é¢ï¼‰
                output_path = self.doc.FileName.replace('.FCStd', '.dxf')
                import importDXF
                importDXF.export(self.doc.Objects, output_path)
                exports['dxf'] = output_path
        
        return exports
```

---

## 8. UIãƒ»çµ±åˆã‚·ã‚¹ãƒ†ãƒ 

### 8.1 Streamlitçµ±åˆUI

```python
# src/ui/main_app.py
import streamlit as st
import asyncio
from src.inference.generator import FloorPlanGenerator
from src.freecad_bridge.fcstd_generator import FreeCADGenerator

class FloorPlanApp:
    def __init__(self):
        self.generator = FloorPlanGenerator()
        self.freecad_gen = FreeCADGenerator()
        
    def run(self):
        st.set_page_config(
            page_title="910mmã‚°ãƒªãƒƒãƒ‰ä½å®…ãƒ—ãƒ©ãƒ³ç”Ÿæˆ",
            page_icon="ğŸ ",
            layout="wide"
        )
        
        st.title("ğŸ  AIä½å®…ãƒ—ãƒ©ãƒ³ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ")
        st.write("910mm/455mmã‚°ãƒªãƒƒãƒ‰ãƒ™ãƒ¼ã‚¹ã®ä½å®…å¹³é¢å›³ã‚’è‡ªå‹•ç”Ÿæˆã—ã€FreeCADã§ç·¨é›†å¯èƒ½ãª3Dãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ")
        
        # ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼šå…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        with st.sidebar:
            st.header("ğŸ“ æ•·åœ°è¨­å®š")
            
            width_grids = st.number_input(
                "æ¨ªå¹…ï¼ˆã‚°ãƒªãƒƒãƒ‰æ•°ï¼‰", 
                min_value=6, max_value=20, value=11,
                help="1ã‚°ãƒªãƒƒãƒ‰ = 910mm"
            )
            
            height_grids = st.number_input(
                "å¥¥è¡Œãï¼ˆã‚°ãƒªãƒƒãƒ‰æ•°ï¼‰", 
                min_value=6, max_value=20, value=10,
                help="1ã‚°ãƒªãƒƒãƒ‰ = 910mm"
            )
            
            st.write(f"å®Ÿå¯¸æ³•: {width_grids * 0.91:.1f}m Ã— {height_grids * 0.91:.1f}m")
            st.write(f"æ•·åœ°é¢ç©: {width_grids * height_grids * 0.91 * 0.91:.1f}ã¡")
            
            # è©³ç´°è¨­å®š
            with st.expander("è©³ç´°è¨­å®š"):
                room_count = st.selectbox("éƒ¨å±‹æ•°", [3, 4, 5], index=1)
                style = st.selectbox("ã‚¹ã‚¿ã‚¤ãƒ«", ["standard", "modern", "traditional"])
                
            generate_btn = st.button("ğŸ¯ å¹³é¢å›³ç”Ÿæˆ", type="primary")
        
        # ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.header("ğŸ“‹ ç”Ÿæˆè¨­å®š")
            if generate_btn:
                with st.spinner("å¹³é¢å›³ã‚’ç”Ÿæˆä¸­..."):
                    self.generate_floorplan(width_grids, height_grids, room_count, style)
        
        with col2:
            st.header("ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰")
            self.show_download_options()
    
    def generate_floorplan(self, width, height, rooms, style):
        """å¹³é¢å›³ç”Ÿæˆãƒ—ãƒ­ã‚»ã‚¹"""
        
        # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼
        progress = st.progress(0)
        status = st.empty()
        
        try:
            # 1. æ•·åœ°ãƒã‚¹ã‚¯ç”Ÿæˆ (20%)
            status.text("æ•·åœ°ãƒã‚¹ã‚¯ã‚’ç”Ÿæˆä¸­...")
            progress.progress(20)
            site_mask = self.generator.create_site_mask(width, height)
            
            # 2. AIæ¨è«– (40%)
            status.text("AIå¹³é¢å›³ã‚’ç”Ÿæˆä¸­...")
            progress.progress(40)
            
            prompt = f"site_size_{width}x{height}, rooms_{rooms}, style_{style}, japanese_house"
            raw_plan = self.generator.generate_plan(site_mask, prompt)
            
            # 3. åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ (60%)
            status.text("å»ºç¯‰åˆ¶ç´„ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...")
            progress.progress(60)
            
            validated_plan = self.generator.validate_constraints(raw_plan)
            
            # 4. ãƒ™ã‚¯ã‚¿å¤‰æ› (80%)
            status.text("ãƒ™ã‚¯ã‚¿å›³é¢ã‚’ä½œæˆä¸­...")
            progress.progress(80)
            
            svg_data = self.generator.to_svg(validated_plan)
            
            # 5. FreeCAD 3DåŒ– (100%)
            status.text("3Dãƒ¢ãƒ‡ãƒ«ã‚’ç”Ÿæˆä¸­...")
            progress.progress(100)
            
            freecad_result = self.freecad_gen.create_3d_model(
                validated_plan, 
                {'site_grid_size': (width, height)},
                f"outputs/freecad/model_{width}x{height}.FCStd"
            )
            
            # ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ã«ä¿å­˜
            st.session_state.generated = True
            st.session_state.svg_data = svg_data
            st.session_state.freecad_path = freecad_result['fcstd_path']
            st.session_state.plan_image = validated_plan
            
            status.text("âœ… ç”Ÿæˆå®Œäº†ï¼")
            progress.progress(100)
            
            # çµæœè¡¨ç¤º
            self.show_results(validated_plan, svg_data)
            
        except Exception as e:
            st.error(f"ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}")
            status.text("âŒ ç”Ÿæˆå¤±æ•—")
    
    def show_results(self, plan_image, svg_data):
        """ç”Ÿæˆçµæœè¡¨ç¤º"""
        
        st.success("å¹³é¢å›³ãŒæ­£å¸¸ã«ç”Ÿæˆã•ã‚Œã¾ã—ãŸï¼")
        
        # ã‚¿ãƒ–ã§çµæœè¡¨ç¤º
        tab1, tab2, tab3 = st.tabs(["ğŸ–¼ï¸ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼", "ğŸ“ è©³ç´°æƒ…å ±", "ğŸ”§ ç·¨é›†ã‚ªãƒ—ã‚·ãƒ§ãƒ³"])
        
        with tab1:
            st.image(plan_image, caption="ç”Ÿæˆã•ã‚ŒãŸå¹³é¢å›³", use_column_width=True)
            
        with tab2:
            # å»ºç¯‰æƒ…å ±è¡¨ç¤º
            room_info = self.analyze_plan(plan_image)
            st.json(room_info)
            
        with tab3:
            st.write("FreeCADã§ç·¨é›†å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸ")
            st.write("- å£ã®åšã¿å¤‰æ›´")
            st.write("- éƒ¨å±‹å¯¸æ³•èª¿æ•´") 
            st.write("- é–‹å£éƒ¨è¿½åŠ ãƒ»å‰Šé™¤")
            st.write("- æè³ªãƒ»è‰²å¤‰æ›´")
    
    def show_download_options(self):
        """ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¡¨ç¤º"""
        
        if st.session_state.get('generated', False):
            st.success("ç”Ÿæˆå®Œäº† - ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½")
            
            # PNGç”»åƒ
            col1, col2, col3 = st.columns(3)
            
            with col1:
                if st.button("ğŸ–¼ï¸ PNG"):
                    plan_bytes = self.generator.to_png_bytes(st.session_state.plan_image)
                    st.download_button(
                        "PNGç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                        plan_bytes,
                        "floorplan.png",
                        "image/png"
                    )
            
            with col2:
                if st.button("ğŸ“„ SVG"):
                    st.download_button(
                        "SVGå›³é¢ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                        st.session_state.svg_data,
                        "floorplan.svg",
                        "image/svg+xml"
                    )
            
            with col3:
                if st.button("ğŸ¯ FreeCAD"):
                    fcstd_bytes = open(st.session_state.freecad_path, 'rb').read()
                    st.download_button(
                        "FreeCADãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                        fcstd_bytes,
                        "floorplan.FCStd",
                        "application/octet-stream"
                    )
        else:
            st.info("å¹³é¢å›³ã‚’ç”Ÿæˆã—ã¦ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™")

if __name__ == "__main__":
    app = FloorPlanApp()
    app.run()
```

---

## 9. é–‹ç™ºã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

### ãƒ•ã‚§ãƒ¼ã‚ºåˆ¥å®Ÿè£…è¨ˆç”»ï¼ˆé€²æ—åæ˜ ç‰ˆï¼‰

| No. | ãƒ•ã‚§ãƒ¼ã‚º                                      | ä¸»è¦ã‚¿ã‚¹ã‚¯                                                                                                                                                                                               | æ‹…å½“ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«/ã‚¹ã‚¯ãƒªãƒ—ãƒˆ                                                                                      | å®Œäº†çŠ¶æ³                    | æ®‹ã‚Šå·¥æ•°ç›®å®‰ |
|-----|-------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|-----------------------------|-------------|
| 1   | **ç’°å¢ƒãƒ»é››å½¢ä½œæˆ**                         | â€¢ é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—<br>â€¢ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ç¢ºç«‹<br>â€¢ ä¸»è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®éª¨æ ¼å®Ÿè£…                                                                                                                                    | `scripts/setup.sh`, `requirements.txt`, å„`src`ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨`__init__.py`ãªã©                              | âœ…å®Œäº†                       | -           |
| 2   | **ãƒ‡ãƒ¼ã‚¿æº–å‚™**                               | â€¢ **å­¦ç¿’ç”¨PDFé…ç½®** (`data/raw_pdfs/`)<br>â€¢ `DimensionExtractor` å®Ÿè£…ç¢ºèª<br>â€¢ `GridNormalizer` å®Ÿè£…ç¢ºèª                                                                                              | `data/raw_pdfs/`, `src/preprocessing/dimension_extractor.py`, `src/preprocessing/grid_normalizer.py` | âœ…å®Œäº†                       | -           |
| 3   | **å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè£… (æœ€é‡è¦ãƒ»æœ€å„ªå…ˆ)** | â€¢ **`TrainingDataGenerator` ã®è©³ç´°å®Ÿè£…:**<br>  - PDFã‹ã‚‰ã®å›³å½¢æƒ…å ±æŠ½å‡ºï¼ˆå£ã€é–‹å£éƒ¨ã€éšæ®µãªã©ï¼‰<br>  - ã‚°ãƒªãƒƒãƒ‰ç”»åƒã¸ã®å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯<br>  - å»ºç¯‰è¦ç´ ã®ãƒãƒ£ãƒ³ãƒãƒ«åˆ†é›¢ãƒ­ã‚¸ãƒƒã‚¯<br>â€¢ `scripts/prepare_training_data.py` ã®å‹•ä½œç¢ºèªã¨æœ¬å®Ÿè¡Œ | `src/preprocessing/training_data_generator.py`                                                       | âœ…å®Ÿè£…å®Œäº†<br>(ã‚¨ãƒ©ãƒ¼å‡¦ç†å¼·åŒ–æ¸ˆã¿) | 0h          |
| 4   | **AIãƒ¢ãƒ‡ãƒ«å­¦ç¿’**                             | â€¢ `FloorPlanDataset` ã®å¾®èª¿æ•´ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰<br>â€¢ `LoRATrainer` ã®å¾®èª¿æ•´ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰<br>â€¢ `scripts/train_model.py` ã‚’ç”¨ã„ãŸãƒ¢ãƒ‡ãƒ«å­¦ç¿’å®Ÿè¡Œ<br>â€¢ å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã®ä¿å­˜ (`models/lora_weights/`)                            | `src/training/dataset.py`, `src/training/lora_trainer.py`, `scripts/train_model.py`                  | éª¨æ ¼å®Ÿè£…æ¸ˆã¿                 | 15h         |
| 5   | **æ¨è«–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè£…**                        | â€¢ **`src/inference/generator.py` (ä»®) ã®å®Ÿè£…:**<br>  - å­¦ç¿’æ¸ˆã¿LoRAãƒ¢ãƒ‡ãƒ«ã®ãƒ­ãƒ¼ãƒ‰<br>  - æ•·åœ°ãƒã‚¹ã‚¯ã¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”¨ã„ãŸå¹³é¢å›³ç”Ÿæˆå‡¦ç†<br>  - (è¦ä»¶å®šç¾©æ›¸ã«ã‚ã‚‹ `FloorPlanGenerator` ã‚¯ãƒ©ã‚¹ã®å½¹å‰²)                                 | `src/inference/generator.py` (æ–°è¦ä½œæˆã¾ãŸã¯æ—¢å­˜`src/generator.py`ã‚’ç§»å‹•ãƒ»ãƒªãƒ•ã‚¡ã‚¯ã‚¿)                          | æœªç€æ‰‹                      | 20h         |
| 6   | **åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…**                      | â€¢ **`ArchitecturalConstraints` ã®è©³ç´°å®Ÿè£…:**<br>  - éƒ¨å±‹ãƒ»éšæ®µã®é€£ç¶šæ€§åˆ¶ç´„<br>  - éƒ¨å±‹é–“ã®æ¥ç¶šæ€§åˆ¶ç´„ï¼ˆã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½æ€§ï¼‰<br>  - `image_to_grid` ã®AIå‡ºåŠ›å½¢å¼ã¸ã®é©åˆ<br>  - `extract_solution` ã®å¾Œç¶šå‡¦ç†ã¸ã®é©åˆ       | `src/constraints/architectural_constraints.py`                                                       | éª¨æ ¼å®Ÿè£…æ¸ˆã¿<br>(ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤š) | 15h         |
| 7   | **FreeCADé€£æºã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…**                   | â€¢ **`FreeCADGenerator` ã®è©³ç´°å®Ÿè£…:**<br>  - AIå‡ºåŠ›/CP-SATå‡ºåŠ›ã‹ã‚‰ã®å£ãƒ»é–‹å£éƒ¨ãƒ»éšæ®µã®æ­£ç¢ºãªæ¤œå‡º<br>  - FreeCADã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯ã®ç²¾ç·»åŒ–<br>â€¢ **`EditingFeatures` ã®è©³ç´°å®Ÿè£…:**<br>  - ã‚¹ã‚±ãƒƒãƒç·¨é›†æ©Ÿèƒ½ã®å…·ä½“åŒ–        | `src/freecad_bridge/fcstd_generator.py`, `src/freecad_bridge/editing_features.py`                    | éª¨æ ¼å®Ÿè£…æ¸ˆã¿<br>(ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤š) | 20h         |
| 8   | **UIãƒ»çµ±åˆã‚·ã‚¹ãƒ†ãƒ **                           | â€¢ `src/ui/main_app.py` ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’å®Ÿãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã«ç½®æ›<br>â€¢ `scripts/generate_plan.py` ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’å®Ÿãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã«ç½®æ›<br>â€¢ å…¨ä½“ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®çµ±åˆã¨å‹•ä½œç¢ºèª                                                        | `src/ui/main_app.py`, `scripts/generate_plan.py`                                                     | éª¨æ ¼å®Ÿè£…æ¸ˆã¿<br>(ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤š) | 15h         |
| 9   | **ãƒ†ã‚¹ãƒˆãƒ»è©•ä¾¡**                              | â€¢ `src/evaluation/metrics.py` ã®è©•ä¾¡ãƒ­ã‚¸ãƒƒã‚¯è©³ç´°å®Ÿè£…<br>â€¢ `scripts/performance_test.py` ã‚’ç”¨ã„ãŸãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ<br>â€¢ å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹ã«åŸºã¥ã„ãŸè©•ä¾¡ã¨æ”¹å–„ç‚¹ã®æ´—ã„å‡ºã—                                                         | `src/evaluation/metrics.py`, `scripts/performance_test.py`                                           | éª¨æ ¼å®Ÿè£…æ¸ˆã¿<br>(ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤š) | 10h         |
| 10  | **æœ€çµ‚èª¿æ•´ãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**                       | â€¢ ãƒã‚°ä¿®æ­£<br>â€¢ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–<br>â€¢ README.md ã®æ›´æ–°ï¼ˆå®Ÿè¡Œæ–¹æ³•ã€æ³¨æ„äº‹é …ãªã©ï¼‰                                                                                                                                 | å…¨ä½“                                                                                                 | æœªç€æ‰‹                      | 5h          |
|     |                                           | **åˆè¨ˆæ®‹ã‚Šå·¥æ•°ç›®å®‰**                                                                                                                                                                                   |                                                                                                      |                             | **130h**    |

**ç›´è¿‘ã®å…·ä½“çš„ãªä½œæ¥­ã‚¹ãƒ†ãƒƒãƒ— (æ¬¡ã®1é€±é–“ç¨‹åº¦ã‚’è¦‹è¾¼ã‚€):**

1.  **`TrainingDataGenerator` ã® `pdf_to_grid_image_placeholder` ã®å®Ÿè£… (æœ€å„ªå…ˆ):** (ç›®æ¨™: 10h)
    *   PDFã‹ã‚‰åŸºæœ¬çš„ãªå£æƒ…å ±ã‚’æŠ½å‡ºã—ã€ã‚·ãƒ³ãƒ—ãƒ«ãªã‚°ãƒªãƒƒãƒ‰ç”»åƒï¼ˆä¾‹ï¼šå£éƒ¨åˆ†ãŒé»’ã€ãã®ä»–ãŒç™½ã®2å€¤ç”»åƒï¼‰ã‚’ç”Ÿæˆã™ã‚‹å‡¦ç†ã‚’å®Ÿè£…ã™ã‚‹ã€‚
    *   ã¾ãšã¯ `PyMuPDF (fitz)` ãªã©ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ç”¨ã„ã¦ã€PDFå†…ã®ç·šåˆ†ãƒ‡ãƒ¼ã‚¿ã‚„ãƒ©ã‚¹ã‚¿ãƒ¼ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã€‚
    *   æŠ½å‡ºã—ãŸç·šåˆ†ã‹ã‚‰ã€ä¸€å®šã®å¤ªã•ã‚’æŒã¤ã‚‚ã®ã‚’å£å€™è£œã¨ã—ã¦ã‚°ãƒªãƒƒãƒ‰ã«æç”»ã™ã‚‹ã€‚

2.  **`TrainingDataGenerator` ã® `separate_elements` ã®å®Ÿè£… (å£ã®ã¿):** (ç›®æ¨™: 5h)
    *   ä¸Šè¨˜ã§ç”Ÿæˆã—ãŸã‚·ãƒ³ãƒ—ãƒ«ãªå£ã®ã‚°ãƒªãƒƒãƒ‰ç”»åƒã‹ã‚‰ã€å£ãƒãƒ£ãƒ³ãƒãƒ« (`rgba[:,:,0]`) ã‚’ä½œæˆã™ã‚‹ã€‚
    *   ä»–ã®ãƒãƒ£ãƒ³ãƒãƒ«ï¼ˆé–‹å£éƒ¨ã€éšæ®µã€éƒ¨å±‹ï¼‰ã¯ä¸€æ—¦ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯ç©ºãƒ‡ãƒ¼ã‚¿ã®ã¾ã¾ã«ã™ã‚‹ã€‚

3.  **å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ:** (ç›®æ¨™: 2h)
    *   `scripts/prepare_training_data.py` ã‚’æ•°å€‹ã®PDFã§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã—ã€`data/training/` ã«å£æƒ…å ±ã®ã¿ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãƒšã‚¢ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã€‚

4.  **`FloorPlanDataset` ã¨ `LoRATrainer` ã®å‹•ä½œç¢ºèª:** (ç›®æ¨™: 3h)
    *   ç”Ÿæˆã•ã‚ŒãŸå£ã®ã¿ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã§ã€å­¦ç¿’ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãŒã‚¨ãƒ©ãƒ¼ãªãæ•°ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œã§ãã‚‹ã‹ç¢ºèªã™ã‚‹ã€‚

**ãƒªã‚¹ã‚¯ç®¡ç†:**
*   **PDFã‹ã‚‰ã®å›³å½¢æƒ…å ±æŠ½å‡ºã®å›°é›£æ€§**: PDFã®æ§‹é€ ã¯å¤šæ§˜ã§ã‚ã‚‹ãŸã‚ã€å®‰å®šã—ãŸæƒ…å ±æŠ½å‡ºã¯éå¸¸ã«é›£ã—ã„ã€‚åˆæœŸæ®µéšã§ã¯å®Œç’§ã‚’ç›®æŒ‡ã•ãšã€ä¸€éƒ¨ã®å˜ç´”ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã®PDFã‹ã‚‰ã§ã‚‚æƒ…å ±ã‚’å–ã‚Œã‚‹ã‚ˆã†ã«æ®µéšçš„ã«ç²¾åº¦ã‚’ä¸Šã’ã‚‹ã€‚
*   **è¦ç´ åˆ†é›¢ã®ç²¾åº¦**: ç”»åƒå‡¦ç†ãƒ™ãƒ¼ã‚¹ã®è¦ç´ åˆ†é›¢ã¯ç²¾åº¦ã«é™ç•ŒãŒã‚ã‚‹ãŸã‚ã€ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚„æ©Ÿæ¢°å­¦ç¿’ãƒ™ãƒ¼ã‚¹ã®æ‰‹æ³•ã‚‚å°†æ¥çš„ã«æ¤œè¨ã™ã‚‹ã€‚MVPã§ã¯ä¸»è¦ãªå£ãŒèªè­˜ã§ãã‚‹ãƒ¬ãƒ™ãƒ«ã‚’ç›®æŒ‡ã™ã€‚
*   **å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ•´åˆæ€§**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã®ãƒ‡ãƒ¼ã‚¿ã®å—ã‘æ¸¡ã—å½¢å¼ï¼ˆç‰¹ã«ç”»åƒã‚„ã‚°ãƒªãƒƒãƒ‰ãƒ‡ãƒ¼ã‚¿ï¼‰ã‚’æ—©æœŸã«æ˜ç¢ºã«ã—ã€ä¸€è²«æ€§ã‚’ä¿ã¤ã€‚

---

## 10. ãƒ†ã‚¹ãƒˆãƒ»è©•ä¾¡

### 10.1 å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹

```python
# src/evaluation/metrics.py
class QualityMetrics:
    def __init__(self):
        self.constraints_checker = ArchitecturalConstraints()
        
    def evaluate_generated_plan(self, plan_image, metadata):
        """ç”Ÿæˆãƒ—ãƒ©ãƒ³ã®å“è³ªè©•ä¾¡"""
        
        metrics = {}
        
        # 1. åˆ¶ç´„å……è¶³ç‡
        constraints_result = self.constraints_checker.validate_and_fix(plan_image)
        metrics['constraint_satisfaction'] = constraints_result is not None
        
        # 2. å¯¸æ³•ç²¾åº¦
        dimension_accuracy = self.check_dimension_accuracy(plan_image, metadata)
        metrics['dimension_accuracy'] = dimension_accuracy
        
        # 3. éƒ¨å±‹é¢ç©å¦¥å½“æ€§
        room_areas = self.calculate_room_areas(plan_image)
        metrics['valid_room_areas'] = self.validate_room_areas(room_areas)
        
        # 4. å‹•ç·šå¦¥å½“æ€§
        circulation_score = self.evaluate_circulation(plan_image)
        metrics['circulation_score'] = circulation_score
        
        # 5. ç·åˆã‚¹ã‚³ã‚¢
        metrics['overall_score'] = self.calculate_overall_score(metrics)
        
        return metrics
    
    def batch_evaluation(self, test_cases):
        """ãƒãƒƒãƒè©•ä¾¡å®Ÿè¡Œ"""
        
        results = []
        success_count = 0
        
        for case in test_cases:
            try:
                metrics = self.evaluate_generated_plan(case['plan'], case['metadata'])
                results.append({
                    'case_id': case['id'],
                    'metrics': metrics,
                    'success': metrics['overall_score'] > 0.6
                })
                
                if metrics['overall_score'] > 0.6:
                    success_count += 1
                    
            except Exception as e:
                results.append({
                    'case_id': case['id'],
                    'error': str(e),
                    'success': False
                })
        
        # çµ±è¨ˆãƒ¬ãƒãƒ¼ãƒˆ
        success_rate = success_count / len(test_cases)
        report = {
            'total_cases': len(test_cases),
            'success_count': success_count,
            'success_rate': success_rate,
            'target_rate': 0.6,  # ç›®æ¨™60%
            'achieved': success_rate >= 0.6
        }
        
        return results, report
```

### 10.2 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

```python
# scripts/performance_test.py
import time
import psutil
import torch

def performance_benchmark():
    """ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ"""
    
    test_cases = [
        {'width': 8, 'height': 8},   # å°è¦æ¨¡
        {'width': 11, 'height': 10}, # ä¸­è¦æ¨¡  
        {'width': 15, 'height': 12}, # å¤§è¦æ¨¡
    ]
    
    app = FloorPlanApp()
    results = []
    
    for case in test_cases:
        print(f"Testing {case['width']}x{case['height']} grid...")
        
        # ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æ¸¬å®šé–‹å§‹
        process = psutil.Process()
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        # GPUä½¿ç”¨é‡ï¼ˆMPSï¼‰
        if torch.backends.mps.is_available():
            torch.mps.empty_cache()
            initial_gpu = torch.mps.current_allocated_memory() / 1024 / 1024  # MB
        
        # å‡¦ç†æ™‚é–“æ¸¬å®š
        start_time = time.time()
        
        try:
            # å…¨ä½“ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ
            result = app.generator.full_pipeline(
                case['width'], 
                case['height']
            )
            
            end_time = time.time()
            processing_time = end_time - start_time
            
            # ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡
            final_memory = process.memory_info().rss / 1024 / 1024
            memory_usage = final_memory - initial_memory
            
            if torch.backends.mps.is_available():
                final_gpu = torch.mps.current_allocated_memory() / 1024 / 1024
                gpu_usage = final_gpu - initial_gpu
            else:
                gpu_usage = 0
            
            results.append({
                'case': case,
                'processing_time': processing_time,
                'memory_usage_mb': memory_usage,
                'gpu_usage_mb': gpu_usage,
                'success': True,
                'target_time': 5.0,  # 5ç§’ä»¥å†…
                'time_achieved': processing_time <= 5.0
            })
            
            print(f"âœ… Success: {processing_time:.2f}s, RAM: {memory_usage:.1f}MB, GPU: {gpu_usage:.1f}MB")
            
        except Exception as e:
            print(f"âŒ Failed: {str(e)}")
            results.append({
                'case': case,
                'error': str(e),
                'success': False
            })
    
    # çµæœé›†è¨ˆ
    successful = [r for r in results if r.get('success', False)]
    avg_time = sum(r['processing_time'] for r in successful) / len(successful)
    time_compliance = sum(1 for r in successful if r['time_achieved']) / len(successful)
    
    print(f"\nğŸ“Š Performance Summary:")
    print(f"Success Rate: {len(successful)}/{len(results)} ({len(successful)/len(results)*100:.1f}%)")
    print(f"Average Time: {avg_time:.2f}s")
    print(f"Time Target Compliance: {time_compliance*100:.1f}%")
    
    return results

if __name__ == "__main__":
    performance_benchmark()
```

---

## ğŸ“¦ å®Ÿè¡Œæ–¹æ³•

### åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
```bash
cd ~/repos/floor_generate

# ç’°å¢ƒæ§‹ç¯‰ï¼ˆä¸Šè¨˜ã®macOSã¾ãŸã¯Ubuntuæ‰‹é †ã‚’å®Ÿè¡Œå¾Œï¼‰
chmod +x setup_dirs.sh
./setup_dirs.sh

# å­¦ç¿’ãƒ‡ãƒ¼ã‚¿æº–å‚™ï¼ˆPDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’ data/raw_pdfs/ ã«é…ç½®å¾Œï¼‰
source floorplan_env/bin/activate
python scripts/prepare_training_data.py --pdf_dir data/raw_pdfs --output_dir data/training

# ãƒ¢ãƒ‡ãƒ«å­¦ç¿’
python scripts/train_model.py --data_dir data/training --epochs 20
```

### æ¨è«–å®Ÿè¡Œ
```bash
cd ~/repos/floor_generate
source floorplan_env/bin/activate

# Streamlit UIèµ·å‹•
streamlit run src/ui/main_app.py --server.port 8501 --server.address 0.0.0.0

# ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³æ¨è«–
python scripts/generate_plan.py --width 11 --height 10 --output outputs/

# ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œï¼ˆå­¦ç¿’ã‹ã‚‰è¡¨ç¤ºã¾ã§ï¼‰
python scripts/train_and_display.py

# å­¦ç¿’ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦Streamlitã®ã¿èµ·å‹•
python scripts/train_and_display.py --skip-training

# ã‚«ã‚¹ã‚¿ãƒ å­¦ç¿’ã‚¨ãƒãƒƒã‚¯æ•°ã‚’æŒ‡å®š
python scripts/train_and_display.py --epochs 30
```

### ä¾å­˜é–¢ä¿‚ã®ç¶­æŒï¼ˆMaintain Dependenciesï¼‰
```bash
cd ~/repos/floor_generate
source floorplan_env/bin/activate
pip install --upgrade pip setuptools wheel
pip install -r requirements.txt --upgrade
pip list --outdated
```

### ãƒ­ãƒ¼ã‚«ãƒ«ã‚¢ãƒ—ãƒªã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆSetup Local Appï¼‰
```bash
cd ~/repos/floor_generate
source floorplan_env/bin/activate

# PDFãƒ‡ãƒ¼ã‚¿ã®å‰å‡¦ç†å®Ÿè¡Œ
python scripts/process_pdfs.py

# å®Œå…¨ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆ
python scripts/performance_test.py

# åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ç¢ºèª
python -c "import torch; print(f'PyTorch: {torch.__version__}')"
python -c "import easyocr; print('EasyOCR imported successfully')"
python -c "import pdf2image; print('PDF2Image imported successfully')"
streamlit --version
```

### FreeCADã§ã®ç·¨é›†
1. ç”Ÿæˆã•ã‚ŒãŸ `.FCStd` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’FreeCADã§é–‹ã
2. `FloorPlanSketch` ã‚’ç·¨é›†ã—ã¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´
3. `WallHeight`, `WallThickness` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§å¯¸æ³•å¤‰æ›´
4. `Arch` ãƒ¯ãƒ¼ã‚¯ãƒ™ãƒ³ãƒã§éƒ¨å±‹ãƒ»è¨­å‚™è¿½åŠ 

---

## ğŸ“Š ç¾åœ¨ã®é€²æ—çŠ¶æ³

### Current Progress (Updated)

- âœ… **Phase 1-3**: ç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆå®Œäº†
- âœ… **Phase 4**: LoRAã‚’ä½¿ç”¨ã—ãŸAIãƒ¢ãƒ‡ãƒ«ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…å®Œäº†
- âœ… **Phase 5**: æ¨è«–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè£…ã¨çµ±åˆå®Œäº†
- âœ… **Phase 6**: åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…ã¨çµ±åˆå®Œäº†
- âœ… **Phase 7**: FreeCADé€£æºã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…å®Œäº†
- âœ… **Phase 8**: å®Ÿéš›ã®å®Ÿè£…ã«ã‚ˆã‚‹UIçµ±åˆå®Œäº†
- âœ… **Phase 9**: ä¾å­˜é–¢ä¿‚ã®äº’æ›æ€§å•é¡Œè§£æ±ºå®Œäº†
  - âœ… huggingface_hubã€diffusersã€transformersã®äº’æ›æ€§ä¿®æ­£
  - âœ… HF_HUB_CACHEå±æ€§ã‚¨ãƒ©ãƒ¼ã®è§£æ±º
  - âœ… ãƒ‘ãƒƒãƒã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè£…
- ğŸ”„ **Phase 10**: ãƒ†ã‚¹ãƒˆã¨è©•ä¾¡é€²è¡Œä¸­
- â³ **Phase 11**: æœ€çµ‚èª¿æ•´ã¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°äºˆå®š

### æœ€è¿‘ã®å®Ÿè£…å†…å®¹

1. **ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³**: å­¦ç¿’ã‹ã‚‰è¡¨ç¤ºã¾ã§ã®ä¸€è²«ã—ãŸãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’å®Ÿè£…
   - `scripts/train_and_display.py` - å­¦ç¿’ã¨Streamlitè¡¨ç¤ºã‚’çµ±åˆ
   - å­¦ç¿’ã‚¹ã‚­ãƒƒãƒ—ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒãƒƒã‚¯æ•°è¨­å®šæ©Ÿèƒ½

2. **ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ç½®æ›**: 
   - `src/ui/main_app.py` ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’å®Ÿéš›ã®AIå®Ÿè£…ã«ç½®æ›
   - å®Ÿéš›ã®åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆ

3. **åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ å¼·åŒ–**:
   - ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®æ”¹å–„
   - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã®è¿½åŠ 
   - å¯è¦–åŒ–æ©Ÿèƒ½ã®å®Ÿè£…

4. **ç”»åƒå¤‰æ›ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£**:
   - PNG/JPGå¤‰æ›æ©Ÿèƒ½
   - Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ©Ÿèƒ½ï¼ˆã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è¡¨ç¤ºç”¨ï¼‰

---

ã“ã®è¦ä»¶å®šç¾©æ›¸ã«å¾“ã£ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€PDFå­¦ç¿’ã‹ã‚‰3Dãƒ¢ãƒ‡ãƒ«ç”Ÿæˆã¾ã§ä¸€æ°—é€šè²«ã—ãŸå®Ÿç”¨çš„ãªMVPãŒæ§‹ç¯‰ã§ãã¾ã™ã€‚å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ç‹¬ç«‹æ€§ã‚’ä¿ã¡ãªãŒã‚‰ã€å…¨ä½“ã¨ã—ã¦çµ±åˆã•ã‚ŒãŸä½å®…è¨­è¨ˆæ”¯æ´ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™ã€‚
